;a code for adding 10 contents of table 0000h and 0010h and store from 0020h
LXI B,0000H
LXI D,0010H
LXI H,0020H
MVI A,0AH
AGAIN:PUSH A
LDAX B
INX B
PUSH B
MOV B,A
LDAX D
ADD B
MOV M,A
POP B
POP PSW
INX H
INX D
DCR A
JNZ AGAIN
HLT

;a code for storing the multiplication of a number at 0000h in 0010h at the interval of 2 seconds
LDA 0000H
MOV B,A
MVI C,0AH
MVI D,01H
L2:XRA A
MOV E,D
L1:ADD B
DCR E
JNZ L1
PUSH A
CALL DELAY
CALL DELAY
POP PSW
STA 0010H
INR D
DCR C
JNZ L2
HLT

;delay of 1 second
DELAY:MVI C,02H
D1: LXI D,FFFFH
D2:DCX D
MOV A,D
ORA E
JNZ D2
DCR C
JNZ D1
RET

;a code to add 10 16 bit datas from 0000h and 0020h and store from 0040h
LXI B,0000H
LXI D,0040H
LXI H,0020H
MVI A,0AH
AGAIN:PUSH A
LDAX B
ADD M
STAX D
INX B
INX D
INX H
LDAX B
ADC M
STAX D
INX B
INX D
INX H
POP PSW
DCR A
JNZ AGAIN
HLT

;a code for placing the number greater than 40h and less than coh else place 00h
LXI B, 0000H
LXI H, 0020H
MVI D,0AH
AGAIN:LDAX B
MVI M,00H
CPI C0H
JNC NEXT
CPI 40H
JC NEXT
MOV M,A
NEXT:INX B
INX H
DCR D
JNZ AGAIN
HLT

;a code to store same value if parity even else store by setting D2 and resetting D7
LXI H, 0010H
LXI D, 0000H
MVI C,0AH
HERE:LDAX D
MOV B,A
ANI FFH
JPO D7D2
MOV M,B
JMP NEXT
D7D2:MOV A,B
ANI 7FH
ORI 04H
MOV M,A
NEXT: INX H
INX D
DCR C
JNZ HERE
HLT

;to add the datas in two table if first table data is smallar then second table value else subtract second from the first one
LXI SP, 00FFH
LXI H,0000H
LXI D, 0010H
LXI B, 0020H

MVI A, 0AH
AGAIN:PUSH PSW
LDAX D
CMP M
JNC ADD1
XCHG
LDAX D
SUB M
XCHG
JMP STORE
ADD1: ADD M
STORE:STAX B
INX H
INX D
INX B
POP PSW
DCR A 
JNZ AGAIN
HLT

;
LXI SP, 00FFH
LXI H, 0000H
MVI D,00H
MVI C, 04H
MVI B,00H
AGAIN:MOV A,M
ANI F0H
CPI 70H
JC SKIP
MOV A,M
ADD B
JNC NEXT
INX D
NEXT:MOV B,A
SKIP: INX H
DCR C
JNZ AGAIN
MOV A,B
MOV M,A
INX H
MOV A,M
HLT

TITLE TO COUNT THE NUMEBERS BETWEEN 50 AND 150
.MODEL SMALL
.STACK 100H
.DATA 
STRING1 DB "THE COUNT: ",'$'
LIST1 DB 0,0,0,150,40,60,63,70,160,'$'
LEN DB $-LIST1
COUNT DB 0

.CODE 
MAIN PROC FAR
MOV AX,@DATA
MOV DS, AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

LEA SI,LIST1
MOV CH,0
MOV CL,LEN
HERE:MOV AX,0
MOV AL,[SI]
CMP AL,51
JB NEXT
CMP AL,149
JA NEXT
ADD COUNT,01H
NEXT:INC SI
LOOP HERE

;DISPLAY COUNT
MOV AH,09H
LEA DX,STRING1
INT 21H

;DISPLAY DECIMAL
MOV AL,COUNT
MOV AH,0
MOV BX,10
MOV CX,00
DECI:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JNZ DECI

MOV AH,02H
SHOW:POP DX
INT 21H
LOOP SHOW


MOV AX,4C00H
INT 21H

MAIN ENDP
END MAIN

TITLE TO FIND THE HCF AND DISPLAY IN DECIMAL OR HEX
.MODEL SMALL
.STACK 100H
.DATA
NUM1 DW 198
NUM2 DW 360
COUNT DB 0

.CODE
MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

;CALCULATION
MOV AX,0
MOV BH,0
MOV BX,NUM1
MOV AX,NUM2
AGAIN:MOV DX,0
DIV BX
CMP DX,0
JE DISPLAY
MOV AX,BX
MOV BX,DX
JMP AGAIN

DISPLAY:MOV AX,BX
CALL DISPLAY_HEX

MOV AX,4C00H
INT 21H

DISPLAY_DECI PROC
MOV BX,10
MOV CX,0
DECI:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JNE DECI

MOV AH,02H
SHOW:POP DX
INT 21H
LOOP SHOW

RET
DISPLAY_DECI ENDP

DISPLAY_HEX PROC
MOV BX,16
MOV CX,0
HEX:MOV DX,0
DIV BX
CMP DX,09H
JA HIGHER
ADD DX,30H
JMP NOW
HIGHER:ADD DX,41H
NOW:PUSH DX
INC CX
CMP AX,0
JNE HEX

MOV AH,02H
SHOWHEX:POP DX
INT 21H
LOOP SHOWHEX

RET
DISPLAY_HEX ENDP

MAIN ENDP
END MAIN

TITLE TO DISPLAY ASCII CHARACTERS IN DEFINED WINDOW
.MODEL SMALL
.STACK 100H
.DATA 
NUM DB 0

.CODE 
MAIN PROC FAR
MOV AX,@DATA
MOV DS, AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

;DEFINING A WINDOW
MOV AH,06H
MOV AL,00
MOV BH,00011111B      ;COLOUR ATRIBUTE
MOV CH,5
MOV CL,10
MOV DH,22
MOV DL,70
INT 10H

MOV DH,11     ;cursor ROW
MOV DL,10 ;CURSOR COLUMN
MOV CX,95 ;COUNT
MOV BL,32 ;VALUE TO BE DISPLAYED
AGAIN:MOV AH,02H ;SET CURSOR POSITION
MOV BH,0  ;PAGE 0
INT 10H 
MOV AH,0EH  ;DISPLAYING IN GRAPHICS MODE
MOV AL,BL   ;DISPLAYING AL
INT 10H

INC BL
INC DL   ;MOVE CURSOR RIGHT
MOV AL,0DH
INT 10H
INC DL   ;MOVE CURSOR RIGHT AFTER BLANK 
CMP DL,70 ;COMAIR WITH THE END OF THE BOX
JNE SKIP
MOV DL,10  ;BACK TO LEFT MOST CORNER
INC DH
SKIP:LOOP AGAIN ;REPEAT UNTILL 122TH CHARACTER IS REACHED

MOV AX,4C00H
INT 21H

MAIN ENDP
END MAIN

TITLE TO SHOW THE SUM OF SERIES 1^2 +2^2 TO N^2
.MODEL SMALL
.STACK 100H
.DATA
STRING1 DB "ENTER THE nTH TERM: ",'$'
STRING2 DB "THE SUM OF THE SERIES IS ",'$'
NUM DB 0
RES DW 0
COUNT DB 0

.CODE
MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

;UI1
MOV AH,09H
LEA DX, STRING1
INT 21H

MOV AX,0

;TAKE ATMOST 2 DIGIT DECIMAL
MOV CX,02
TAKEDECI:MOV AH,01H
INT 21H
CMP AL,0DH
JE LP
SUB AL,30H
PUSH AX
MOV AL,10
MUL NUM
MOV NUM,AL
POP AX
ADD NUM,AL
INC COUNT
LP: LOOPNE TAKEDECI

;SUMMATION
MOV CH,0
MOV CL,NUM
AGAIN:MOV AX,0
MOV BX,0
MOV BL,CL
MOV AL,CL
MUL BL
ADD RES,AX
LOOP AGAIN

;NEW LINE
MOV AH,02H
MOV DX,0AH
INT 21H
MOV DX,0DH
INT 21H

;UI2
MOV AH,09H
LEA DX,STRING2
INT 21H

;DISPLAY ANSWER IN DECIMAL
MOV AX,0
MOV AX,RES
CALL DISP_DECIMAL

MOV AX,4C00H
INT 21H

DISP_DECIMAL PROC
MOV BX,10
MOV CX,0
HERE:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JA HERE

MOV AH,02H
DISP: POP DX
INT 21H
LOOP DISP
RET
DISP_DECIMAL ENDP

MAIN ENDP
END MAIN

TITLE TO CONVERT THE VOWELS TO UPPER CASE IN THE STRING ENTERED BY THE USER
.MODEL SMALL
.STACK 100H
.DATA
STRING1 DB "ENTER THE STRING: ",'$'
STRING2 DB "VOWELS TO UPPERCASE: ",'$'
NUM DB 0
COUNT DB 0
STRING LABEL BYTE
MAXLEN DB 30
ACCTUAL DB ?
INPUT DB 30 DUP('$')

.CODE
MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

;UI1
MOV AH,09H
LEA DX, STRING1
INT 21H

;TAKE INPUT
MOV AH, 0AH
LEA DX, STRING
INT 21H

MOV SI,OFFSET STRING
MOV CH,0
MOV CL,ACCTUAL+2
MOV BX,0
AGAIN:MOV AL,[SI]
CMP AL,'a'
JE TOUPPER
CMP AL,'e'
JE TOUPPER
CMP AL,'i'
JE TOUPPER
CMP AL,'o'
JE TOUPPER
CMP AL,'u'
JE TOUPPER
NEXT:INC SI
LOOP AGAIN
JMP UI2

TOUPPER:SUB AL,20H
MOV [SI],AL
JMP NEXT

UI2:MOV AH,02H
MOV DX,0AH
INT 21H
MOV DX,0DH
INT 21H

MOV AH,09H
LEA DX,STRING2
INT 21H

LEA DX,STRING+2
INT 21H

MOV AX,4C00H
INT 21H

MAIN ENDP
END MAIN

TITLE TO ALTER THE CASES OF THE STRING ENTERED BY THE USER
.MODEL SMALL
.STACK 100H
.DATA
STRING1 DB "ENTER THE STRING: ",'$'
STRING2 DB "TO UPPER OR LOWERCASE: ",'$'
NUM DB 0
COUNT DB 0
STRING LABEL BYTE
MAXLEN DB 30
ACCTUAL DB ?
INPUT DB 30 DUP('$')

.CODE
MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

;CLEAR SCREEN
MOV AH,00H
MOV AL,03H
INT 10H

;UI1
MOV AH,09H
LEA DX, STRING1
INT 21H

;TAKE INPUT
MOV AH, 0AH
LEA DX, STRING
INT 21H

MOV SI,OFFSET STRING
MOV CH,0
MOV CL,ACCTUAL+2
MOV BX,0
AGAIN:MOV AL,[SI]
CMP AL, 65;
JB NEXT
CMP AL, 90;Z
JA TOUPPER
ADD AL,20H
JMP NEXT
TOUPPER:CMP AL,122;
JA NEXT
CMP AL,97;
JB NEXT
SUB AL,20H 
NEXT:MOV [SI],AL
INC SI
LOOP AGAIN
JMP UI2


UI2:MOV AH,02H
MOV DX,0AH
INT 21H
MOV DX,0DH
INT 21H

MOV AH,09H
LEA DX,STRING2
INT 21H

LEA DX,STRING+2
INT 21H

MOV AX,4C00H
INT 21H

MAIN ENDP
END MAIN


TITLE TO MOVE THE USER ENTERD STRING TOWARDS RIGHT
.MODEL SMALL
.STACK 32
.DATA
DEL DW 65535
LOCATION DW 0000H
STRING LABEL BYTE
MAXLEN DB 20
ACCTUAL DB ?
INPUT DB 20 DUP('$')

.CODE
MAIN PROC FAR
MOV AX, @DATA
MOV DS, AX

CALL CLEAR_SCREEN
CALL GET_STRING
MOV CX,38
MOVE:CALL CLEAR_SCREEN
MOV DX,LOCATION
CALL SET_CURSOR
CALL DISPLAY_STRING
CALL DELAY
ADD LOCATION,02
LOOP MOVE
CALL END_PROG

END_PROG PROC
MOV LOCATION,0000H
MOV AH,4CH
INT 21H
RET
END_PROG ENDP

SET_CURSOR PROC
MOV AH,02H
MOV BH,00
INT 10H
RET
SET_CURSOR ENDP

CLEAR_SCREEN PROC
MOV AH,00H
MOV AL,03H
INT 10H
RET
CLEAR_SCREEN ENDP

DISPLAY_STRING PROC
DISPLAY:MOV AH,09H
LEA DX,STRING+2
INT 21H
RET
DISPLAY_STRING ENDP

GET_STRING PROC
MOV AH, 0AH
LEA DX,STRING
INT 21H
RET
GET_STRING ENDP

DELAY PROC
MOV AX,5
D2:MOV BX,DEL
D1:DEC BX
JNZ D1
DEC AX
JNZ D2
RET
DELAY ENDP

MAIN ENDP
END MAIN

TITLE TO STORE 1FFFH IN LIST3 IF LIST2 IS LESS THAN LIST2, ELSE 0000H IN LST3
.MODEL SMALL
.STACK 64
.DATA
COUNT DB 10
LST1 DW 1111,2222,3333,4444,5555,6666,1111,1111,2222,2222,'$'
LST2 DW 1211,3222,3322,4414,5525,6646,1181,1191,2220,2202,'$'
LST3 DW ?

.CODE
NEWLINE MACRO
MOV AH,02H
MOV DL,0DH
INT 21H
MOV DL,0AH
INT 21H
ENDM

MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

MOV CX,0
MOV CL,10

LEA SI,LST1
LEA DI,LST2
MOV BX,0

AGAIN:MOV AX,[SI]
CMP AX,[DI]
JC SMALLAR
MOV [LST3+BX],0000H
JMP SKIP
SMALLAR: MOV [LST3+BX],1FFFH
SKIP:ADD SI,2
ADD DI,2
ADD BX,2
LOOP AGAIN


LEA SI,LST3
DISPLAY:MOV AX,[SI]
CALL DISPLAY_DECIMAL
ADD SI,2
NEWLINE
DEC COUNT
JNZ DISPLAY

MOV AX,4C00H
INT 21H

DISPLAY_DECIMAL PROC

MOV BX,10
STEP3:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JA STEP3

MOV AH,02H
DISP:POP DX
INT 21H
LOOP DISP
RET
DISPLAY_DECIMAL ENDP

MAIN ENDP
END MAIN 

TITLE TO DISPLAY EACH WORDS IN NEWLINE
.MODEL SMALL
.STACK 64
.DATA
STRING LABEL BYTE
MAXLEN DB 254
ACCTUAL DB ?
INPUT DB 254 DUP('$')
ROW DB 10
COL DB 35

.CODE
NEWLINE MACRO
PUSH AX
MOV AH,02H
MOV DL,0DH
INT 21H
MOV DL,0AH
INT 21H
POP AX
ENDM

CLS MACRO
PUSH AX
MOV AH,00
MOV AL,03H
INT 10H
POP AX
ENDM

MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

MOV AH,0AH
LEA DX,MAXLEN
INT 21H

CLS
MOV BX,0
MOV CH,0
MOV CL,ACCTUAL

CALL SETCURSOR
AGAIN:CMP INPUT[BX],32
JNE WORDS
INC ROW
NEWLINE
CALL SETCURSOR
JMP NEXT
WORDS: MOV AH,02H
MOV DL,INPUT[BX]
MOV DH,0
INT 21H

NEXT: INC BX
LOOP AGAIN

MOV AX,4C00H
INT 21H

SETCURSOR PROC
PUSH BX
MOV AH,02H
MOV BH,00H
MOV DH,ROW
MOV DL,COL
INT 10H
POP BX
RET
SETCURSOR ENDP

DISPLAY_DECIMAL PROC

MOV BX,10
STEP3:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JA STEP3

MOV AH,02H
DISP:POP DX
INT 21H
LOOP DISP
RET
DISPLAY_DECIMAL ENDP

MAIN ENDP
END MAIN 

;lower to uppercase and display
CLS
MOV BX,0
MOV CH,0
MOV CL,ACCTUAL

AGAIN:CMP INPUT[BX], 'a'
JB NEXT
CMP INPUT[BX],'z'
JA NEXT
SUB INPUT[BX],20H
NEXT:INC BX
LOOP AGAIN

MOV AH,09H
LEA DX,INPUT
INT 21H


;display in next line in a cleared screen
.DATA
count db 0

CLS
MOV BX,0
MOV CH,0
MOV CL,ACCTUAL

AGAIN:CMP INPUT[BX],32
JNE WORDS
NEWLINE
INC COUNT
JMP NEXT
WORDS: MOV AH,02H
MOV DL,INPUT[BX]
MOV DH,0
INT 21H
NEXT:INC BX
LOOP AGAIN

TITLE to display the multiplication table of entered number
.model small
.stack 64
.data
.code
newline macro
push ax
push dx
mov ah,02h
mov dl,0dh
int 21h
mov dl,0ah
int 21h
pop dx
pop ax
endm

main proc far
mov ax,@data
mov ds,ax

mov ah,07h
int 21h
sub al,30h  ;to decimal value

mov cx,10
mov dl,1

l1:mov ah,0
push ax
mul dl

push dx
push cx

;display decimal
mov bx,10
mov cx,0
deci:mov dx,0
div bx
add dx,30h
push dx
inc cx
cmp ax,0
ja deci

mov ah,02h
disp:pop dx
int 21h
loop disp
newline

pop cx
pop dx
inc dx
pop ax
loop l1

mov ax,4c00h
int 21h

main endp
end main

TITLE TO FIND THE FACTORIAL AND DISPLAY ( 0 TO 9)
.MODEL SMALL
.STACK 64
.DATA
ST1 DB 'ENTER A NUMBER BETWEEN 0 TO 9: $'
ST2 DB 'THE FACTORIAL: $'

.CODE
NEWLINE MACRO
PUSH AX
PUSH DX
MOV AH,02H
MOV DL,0AH
INT 21H
MOV DL,0DH
INT 21H
POP AX
POP DX
ENDM

CLS MACRO
PUSH AX
MOV AH,00H
MOV AL,03H
INT 10H
POP AX
ENDM

MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

MOV AH,09H ;PROMPT 1
LEA DX,ST1
INT 21H

MOV AH,01H
INT 21H

SUB AL,30H ; TO DECIMAL

MOV DX,0
MOV CX,0
MOV CL,AL
MOV AL,1

AGAIN:MUL CL
LOOP AGAIN

PUSH AX
CLS
MOV AH,09H
LEA DX,ST2
INT 21H

POP AX
;INTO DECIMAL

MOV BX,10
MOV CX,0
DECI:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JA DECI

MOV AH,02H
DISP:POP DX
INT 21H
LOOP DISP

MOV AX,4C00H
INT 21H

MAIN ENDP
END MAIN

;ATTEMPT
.MODEL SMALL
.STACK 64
.DATA
COUNT DB 0
VOWELS DB 'aeiouAEIOU$'
NUMERALS DB '1234567890$'
countv db 0
countc db 0
countn db 0
counto db 0
STRING LABEL BYTE
MAXLEN DB 254
ACCTUAL DB ?
INPUT DB 254 DUP('$')

.CODE
NEWLINE MACRO
PUSH AX
MOV AH,02H
MOV DL,0DH
INT 21H
MOV DL,0AH
INT 21H
POP AX
ENDM

CLS MACRO
PUSH AX
MOV AH,00
MOV AL,03H
INT 10H
POP AX
ENDM

MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX

MOV AH,0AH
LEA DX,MAXLEN
INT 21H

CLS
MOV BX,0
MOV CH,0
MOV CL,ACCTUAL

AGAIN:CMP INPUT[BX],'A'
JB CHECK2
CMP INPUT[BX],'z'
JA CHECK2

MOV DL,INPUT[BX]
PUSH BX
PUSH CX
MOV BX,0
MOV CX,10
HERE:CMP VOWELS[BX],DL
JNE NEXT
INC countv
MOV DH,01H
NEXT:INC BX
LOOP HERE
DEC DH
JNZ L1
INC countc
L1:POP CX
POP BX
JMP AARKO

CHECK2:MOV DL,INPUT[BX]
PUSH BX
PUSH CX
MOV BX,0
MOV CX,10
L2:CMP NUMERALS[BX],DL
JNE OTHER
INC countn
MOV DH,01H
OTHER:INC BX
LOOP L2
DEC DH
JNZ L4
INC counto
l4:POP CX
POP BX

AARKO:INC BX
LOOP AGAIN

MOV AH,0
MOV AL,countv
CALL DISPLAY_DECIMAL
NEWLINE
MOV AL,countC
CALL DISPLAY_DECIMAL
NEWLINE
MOV AL,countn
CALL DISPLAY_DECIMAL
NEWLINE
MOV AL,counto
CALL DISPLAY_DECIMAL
NEWLINE

MOV AX,4C00H
INT 21H

DISPLAY_DECIMAL PROC
MOV BX,10
STEP3:MOV DX,0
DIV BX
ADD DX,30H
PUSH DX
INC CX
CMP AX,0
JA STEP3

MOV AH,02H
DISP:POP DX
INT 21H
LOOP DISP
RET
DISPLAY_DECIMAL ENDP

MAIN ENDP
END MAIN 